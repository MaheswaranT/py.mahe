<!DOCTYPE html>
<html>
<head>
    <title>Python Programs with Output</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 20px;
            background-color: #f4f4f4;
        }
        .program {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            box-shadow: 0px 0px 10px rgba(0,0,0,0.1);
        }
        pre {
            background: #eee;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>Python Programs with Output</h1>
    <div class="program">
        <h2>1. Binary Search</h2>
        <pre>
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        mid_value = arr[mid]
        if mid_value == target:
            return mid
        elif mid_value > target:
            high = mid - 1
        else:
            low = mid + 1
    return -1
arr = [1, 3, 5, 7, 9, 11, 13, 15, 17]
target = 7
result = binary_search(arr, target)
if result != -1:
    print(f"Element found at index {result}")
else:
    print("Element not found")
        </pre>
        <h3>Output:</h3>
        <pre>Element found at index 3</pre>
    </div>
    
    <div class="program">
        <h2>2. Sorted Path</h2>
        <pre>
graph = {
    1: [3, 2],
    2: [4],
    3: [4],
    4: [5],
    5: []
}
def sorted_path(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return path
    if start not in graph:
        return None
    for neighbor in sorted(graph[start]):
        new_path = sorted_path(graph, neighbor, end, path)
        if new_path:
            return new_path
    return None
start_node = 1
end_node = 5
path = sorted_path(graph, start_node, end_node)
if path:
    print(f"Sorted path from {start_node} to {end_node}: {path}")
else:
    print("No path found")
        </pre>
        <h3>Output:</h3>
        <pre>Sorted path from 1 to 5: [1, 2, 4, 5]</pre>
    </div>
    
    <div class="program">
        <h2>3. In Order Traverse</h2>
        <pre>
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def in_order(root):
    if root:
        in_order(root.left)
        print(root.value, end=" ")
        in_order(root.right)
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
in_order(root)
        </pre>
        <h3>Output:</h3>
        <pre>4 2 5 1 3</pre>
    </div>
    
    <div class="program">
        <h2>4. Factorial Of Number Using Array</h2>
        <pre>
def factorial(n):
    result = [1]
    for i in range(1, n + 1):
        result[0] *= i
    return result[0]
number = 5
print(f"Factorial of {number} is: {factorial(number)}")
        </pre>
        <h3>Output:</h3>
        <pre>Factorial of 5 is: 120</pre>
    </div>
    
    <div class="program">
        <h2>5. Bubble Using List </h2>
        <pre>
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
arr = [64, 34, 25, 12, 22, 11, 90]
print("Original array:", arr)
bubble_sort(arr)
print("Sorted array:", arr)
        </pre>
        <h3>Output:</h3>
        <pre>Original array: [64, 34, 25, 12, 22, 11, 90]
Sorted array: [11, 12, 22, 25, 34, 64, 90]</pre>
    </div>
    
    <div class="program">
        <h2>6. Circular Linked List</h2>
        <pre>
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class CircularLinkedList:
    def __init__(self):
        self.head = None
    def append(self, value):
        new_node = Node(value)
        if not self.head:
            self.head = new_node
            new_node.next = self.head
        else:
            current = self.head
            while current.next != self.head:
                current = current.next
            current.next = new_node
            new_node.next = self.head
    def display(self):
        if not self.head:
            print("The list is empty.")
            return
        current = self.head
        while True:
            print(current.value, end=" -> ")
            current = current.next
            if current == self.head:
                break
        print("... (circular)")
cll = CircularLinkedList()
cll.append(10)
cll.append(20)
cll.append(30)
        </pre>
        <h3>Output:</h3>
        <pre>10 -> 20 -> 30 -> ... (circular)</pre>
    </div>

    <div class="program">
        <h2>7. Stack</h2>
        <pre>            
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        return self.stack.pop() if self.stack else "Empty"

    def display(self):
        return self.stack or "Empty"

def main():
    stack = Stack()
    while True:
        choice = input("\n1. Push\n2. Pop\n3. Display\n4. Exit\n> ")
        if choice == '1':
            stack.push(input("Item: "))
        elif choice == '2':
            print(stack.pop())
        elif choice == '3':
            print(stack.display())
        elif choice == '4':
            break

if __name__ == "__main__":
    main()
        </pre>
        <h3>Output:</h3>
        <pre>1. Push
2. Pop
3. Display
4. Exit
> 1
            
Item: 23 45 67 89 21
            </pre>
    </div>

    <div class="program">
        <h2>8. Graph</h2>
        <pre>            
import networkx as nx
import matplotlib.pyplot as plt
G = nx.DiGraph()
G.add_nodes_from(["j", "k", "a", "d", "s"])
G.add_weighted_edges_from([
    ("j", "k", 2),
    ("k", "a", 5),
    ("a", "d", 3),
    ("d", "s", 1),
    ("s", "j", 4)
])
pos = nx.circular_layout(G)
nx.draw(G, pos, with_labels=True, node_color="grey", node_size=2000, font_size=15)
nx.draw_networkx_edge_labels(G, pos, edge_labels=nx.get_edge_attributes(G, 'weight'), font_color="purple")
plt.title("Directed Graph with Weights")
plt.show()
    </div>

    <div class="program">
        <h2>9. Sorted Array</h2>
        <pre>            
import bisect
my_list = [25, 45, 36, 47, 69, 48, 68, 78, 14, 36]
print("Original List")
print(my_list)
sorted_list = []
for i in my_list:
    position = bisect.bisect(sorted_list, i)
    bisect.insort(sorted_list, i)
print("Sorted List")
print(sorted_list)

        </pre>
        <h3>Output:</h3>
        <pre>Original List
[25, 45, 36, 47, 69, 48, 68, 78, 14, 36]
Sorted List
[14, 25, 36, 36, 45, 47, 48, 68, 69, 78]          
        </pre>
    </div>

    <div class="program">
        <h2>10. Queue</h2>
        <pre>            
q = []  
n = int(input("Enter the number of elements to add to the queue: "))
for _ in range(n):
    q.append(int(input("Enter element: ")))
print("Initial Queue:", q)
m = int(input("Enter the number of elements to remove from the queue: "))
for _ in range(m):
    if q:
        print("Removed element:", q.pop(0))
    else:
        print("Queue is empty. Cannot remove more elements.")
        break
print("Queue after removals:", q)
def is_empty():
    return len(q) == 0
def size():
    return len(q)
print("Is the queue empty?", is_empty())
print("Size of the queue:", size())

        </pre>
        <h3>Output:</h3>
        <pre>Enter the number of elements to add to the queue: 
Enter element: 6
Enter element: 7
Enter element: 4
Enter element: 3
Initial Queue: [6, 7, 4, 3]
Enter the number of elements to remove from the queue: 2
Removed element: 6
Removed element: 7
Queue after removals: [4, 3]
Is the queue empty? False
Size of the queue: 2
        </pre>
    </div>

</body>
</html>
